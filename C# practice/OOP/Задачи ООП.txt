Задача 1:
Создать класс игрока, с полями, содержащими информацию об игроке и методом, 
который выводит информацию на экран.

В классе обязательно должен быть конструктор


Задача 2:
Создать класс игрока, у которого есть данные с его положением в x,y и своим символом.
Создать класс отрисовщик, с методом, который получает игрока и отрисовывает его. 
Используйте автореализуемое свойство.


Задача 3:
Реализовать базу данных игроков и методы для работы с ней. Должно быть консольное меню для взаимодействия пользователя с возможностями базы данных.
Игрок должен состоять из уникального номера, ника, уровня и булевого значения, забанен ли игрок.
Реализовать возможность добавления игрока, бана игрока по уникальному номеру, разбана игрока по уникальному номеру и удаление игрока по уникальному номеру.

Создавать полноценные системы баз данных не нужно, задание выполняется инструментами, которые вы уже изучили в рамках курса. Надо сделать класс "База данных".


Задача 4:
Есть крупье (или игральный стол), который содержит колоду карт и игрока.
Пользователь задает количество карт, которое надо получить игроку 
и крупье передает из колоды в игрока данное количество карт. 
После выводится вся информация о картах игрока. 
Будут классы: Крупье, Игрок, Колода, Карта.


Задача 5:
Создать хранилище книг. 
Каждая книга имеет название, автора и год выпуска (можно добавить еще параметры). 
В хранилище можно добавить книгу, убрать книгу, показать все книги и показать найденные книги по указанному параметру (по названию, по автору, по году выпуска).

Пример поиска.
Выбирается поиск по названию, вводится название и показываются все книги с данным названием.


Задача 6:
Вам надо создать магазин с продавцом  и покупателем.
Продавец имеет список своих товаров, которые может показать и продавать их. Продажа заключается в передаче покупателю товара и увеличение у себя денег. 
Покупатель также имеет список товаров, что он купил, количество своих денег и всё это может показать.
Продавец может только продавать, а покупатель - только покупать. 
В задаче понадобится использовать наследование.


Задача 7:
Реализовать класс диспетчера, который создает поезда.
Консольное меню состоит из двух пунктов: создания поезда и завершения работы.
Создание поезда состоит из нескольких шагов. 
- Создать направление - создает направление для поезда(к примеру Бийск - Барнаул)
- Продать билеты - вы получаете рандомное кол-во пассажиров, которые купили билеты на это направление
- Сформировать поезд - вы создаете сам поезд и добавляете ему столько вагонов, сколько хватит для перевозки всех пассажиров. Вагон содержит сколько может поместить в себе пассажиров. Можно сделать как одинаковую вместимость всех вагонов, так и разную.
- Показываете полную информацию о созданном поезде. 
Шаги создания поезда должны быть в строгой последовательности не зависящем от выбора пользователя.
Диспетчер содержит все созданные поезда и перед выбором в консольном меню показать короткую информацию каждого поезда.


Задача 8:
Спецификация

Программа начинается с приветственного сообщения арены Колизея.

Пользователь выбирает двух доступных бойцов из списка.

Бой происходит между двумя выбранными бойцами.

Информация о действиях бойцов выводится в консоль.

После боя выводится сообщение о победителе или ничьей.

После боя пользователь может выбрать новых бойцов.

Выход из программы осуществляется через команду консольного меню.


Главное консольное меню

Приветственное сообщение

Посмотреть бой

Выход из программы


Боец

У каждого бойца можно посмотреть его характеристики (тип/название, показатели урона, защиты, здоровья). Боец должен обладать уникальной характеристикой, а так же уметь атаковать другого бойца и принимать урон


Типы бойцов Колизея

Первый боец имеет некий шанс нанести удвоенный урон

Второй боец каждую третью свою атаку наносит дважды урон врагу. 

Третий получая по себе урон накапливает ярость, после накопления максимума, использует лечение. 

У четвертого есть мана и пока её достаточно для применения заклинания “Огненный шар”, он применяет данное заклинание. Заклинание так же наносит урон, но урон больше от изначального.

А пятый имеет шанс уклониться, когда по нему наносят урон.

Допускается создание других типов бойцов.


Выбор бойца

Выбор бойца происходит путем ввода порядкового номера бойца из представленного списка.

Выбранный боец не исчезает из списка доступных бойцов.

Для боя можно выбрать бойцов одинакового типа


Бой

Бой происходит в автоматическом режиме, каждое действие бойцов выводится в консоль. 

Например, такой-то боец применил умение и нанес двойной урон. Такой-то боец применил уворот. 

Вывести информацию о статах бойцов после обмена ударами. 


Механика боя 

Выбрать любую для реализации :

Бойцы атакуют друг друга, бой длится пока оба бойца живы (имитация боя в реальном времени)

Боец атакует только если он жив на момент удара (имитация пошагового боя). При этом очередность ударов заранее определена (сначала первый, потом второй) или очередность удара каждый раз определяется случайным образом 


Особенности кода

Неверный ввод пользователя не должен приводить в поломке программы. Необходимо выводить информационное сообщения о неверном вводе и какие данные ожидаются на ввод от пользователя.

При выборе одинаковых бойцов это не должна быть одна и та же ссылка на одного бойца, чтобы он не атаковал сам себя.


Решение со звездочкой  (не обязательно к выполнению)

Передавать в метод атаки бойца под интерфейсом IDamageable, чтобы у защищающегося стал доступен только один публичный метод TakeDamage(int damage)


Язык интерфейса: русский, допускается транслитерация

Платформа: консольное приложение (.NET Framework)

Язык разработки: C#

Навыки, которыми программист должен овладеть после выполнения задания

Закрепление навыков наследования. 

Атаки не должны увеличивать здоровье врага

Чтобы не допускать дублирования создания объектов Random в разных классах - создание отдельного класса UserUtils, приватного статичного поля Random s_random и метода public static int GenerateRandomNumber(int min, int max).  Обращение к данному методу напрямую, без создания объекта класса UserUtils. Например:  int index = UserUtils.GenerateRandomNumber(_fighters.Count)

Проблема ссылочных типов: создание копии бойца при его выборе из списка, чтобы не было ссылки на одну и ту же область памяти (ознакомление с клонированием объекта). Для создания копии объекта А, создаем объект Б, которому в конструктор передаем данные объекта А. Например, new Б(А.имя, А.рост, А.вес).

Использование интерфейса (для решения со звездочкой)


Задача 9:
Написать программу администрирования супермаркетом.
Супермаркет содержит список товаров, которые он продает, очередь клиентов, которых надо обслужить и количество денег, которые заработаны. Список товаров у супермаркета не уменьшаем, считаем их бесконечное количество. Очередь клиентов можно задавать сразу, так и добавлять по необходимости. Но при обслуживании одного клиента, он удаляется из очереди. 
У клиента есть деньги, корзина и сумка. В корзине все товары, что не куплены, а в сумке все купленные. 
При обслуживании клиента проверяется, может ли он оплатить товар, то есть сравнивается итоговая сумма покупки и количество денег. Если оплатить клиент не может, то он случайный товар из корзины выкидывает до тех пор, пока его денег не хватит для оплаты.


Задача 10:
Реализовать 2 взвода и их сражение.
Каждый взвод внутри имеет солдат.
Каждый солдат - это уникальная единица, имеет способность и свои характеристики.
Солдаты атакуют случайных солдат во вражеском взводе.
Характеристики солдат состоят из здоровья, урона и брони.

Реализовать 4 типа солдат.
Первый - обычный солдат, без особенностей.
Второй - атакует только одного, но с множителем урона.
Третий - атакует сразу нескольких, без повторения атакованного за свою атаку.
Четвертый - атакует сразу нескольких, атакованные солдаты могут повторяться.

Сражение происходит “толпа на толпу”. 
Первый взвод атакует второй взвод и потом наоборот. За время атаки каждый боец проводит свою атаку. После атаки двух взводов остаются в каждом взводе только живые бойцы.
Побеждает тот взвод, в котором остались выжившие бойцы.


Задача 11:
Есть аквариум, в котором плавают рыбы. В этом аквариуме может быть максимум определенное кол-во рыб. Рыб можно добавить в аквариум или рыб можно достать из аквариума. (программу делать в цикле для того, чтобы рыбы могли “жить”) 

Все рыбы отображаются списком, у рыб также есть возраст. За 1 итерацию рыбы стареют на определенное кол-во жизней и могут умереть. Рыб также вывести в консоль, чтобы можно было мониторить показатели.


Задача 12:
Пользователь запускает приложение и перед ним находится меню, в котором он может выбрать, к какому вольеру подойти. При приближении к вольеру, пользователю выводится информация о том, что это за вольер, сколько животных там обитает, их пол и какой звук издает животное.

Вольеров в зоопарке может быть много, в решении нужно создать минимум 4 вольера.


Задача 13:
У вас есть автосервис, в котором будут машины для починки.
Автосервис содержит баланс денег и склад деталей. В автосервисе стоит очередь машин.
Машина состоит из деталей и количество поломанных будет не меньше 1 детали. Надо показывать все детали, которые поломанные.
Поломка всегда чинится заменой детали. При починке машины за раз можно заменять только одну деталь. При успешной починке детали сервис получает (цена детали + цена ремонта).
Ремонт считается завершенным, когда все детали машины исправны. 
От ремонта можно отказаться в любой момент.
Если отказ перед ремонтом, то платите фиксированный штраф.
Если отказ во время ремонта, то платите штраф за каждую непочиненную деталь.
Количество деталей на складе ограничено.
При замене целой детали в машине, деталь пропадает из склада, но вы ничего не получаете за замену данной детали. 
За каждую удачную починку вы получаете выплату за ремонт, которая указана в чек-листе починки.
Класс Деталь не может содержать значение “количество”. Деталь всего одна, за количество отвечает тот, кто хранит детали. При необходимости можно создать дополнительный класс для конкретной детали и работе с количеством.